<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>YOURGIRLSRABBIT â€“ star + circle dissolve (OBS-safe)</title>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
  :root{
    --main:#b06fff;      /* bright purple */
    --secondary:#6b24a5; /* deep purple */
    --outline:#000000;   /* black outline */
    --glow:#d9b3ff;      /* light purple glow */
  }
  html,body{height:100%;margin:0;background:transparent;overflow:hidden}
  canvas{width:100vw;height:100vh;display:block}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const CAN = document.getElementById('c');
  const CTX = CAN.getContext('2d');

  // Offscreen layer we erase into
  const LAYER = document.createElement('canvas');
  const LCTX  = LAYER.getContext('2d', { willReadFrequently: true });

  const TEXT = 'YOURGIRLSRABBIT';
  const FONT = 'Press Start 2P, monospace';

  // Timing
  const BLINKS = 5, BLINK_PERIOD = 1000;
  const STAR_TIME = 8000;     // ms
  const STAR_SPINS = 8;       // rotations for the 5-line star

  let bounds = {x:0,y:0,w:0,h:0,px:0};
  let finished = false;

  function resize(){
    const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
    CAN.width  = Math.floor(CAN.clientWidth * dpr);
    CAN.height = Math.floor(CAN.clientHeight * dpr);
    CTX.setTransform(dpr,0,0,dpr,0,0);

    LAYER.width  = CAN.clientWidth;
    LAYER.height = CAN.clientHeight;
    LCTX.setTransform(1,0,0,1,0,0);

    drawTextLayer();
  }
  window.addEventListener('resize', resize, {passive:true});

  const css = n => getComputedStyle(document.documentElement).getPropertyValue(n).trim();

  function drawTextLayer(){
    const W = LAYER.width, H = LAYER.height;
    const base = Math.min(W, H);
    const px = Math.max(28, Math.floor(base * 0.085));

    LCTX.clearRect(0,0,W,H);
    LCTX.font = `${px}px ${FONT}`;
    LCTX.textBaseline = 'alphabetic';

    const m = LCTX.measureText(TEXT);
    const textW = m.width;
    const textH = (m.actualBoundingBoxAscent || 0) + (m.actualBoundingBoxDescent || 0) || px*1.1;
    const x = Math.round((W - textW)/2);
    const y = Math.round((H + textH)/2 - textH*0.2);

    // Outline
    LCTX.lineJoin = 'round';
    LCTX.strokeStyle = css('--outline');
    LCTX.lineWidth   = Math.max(3, Math.round(px * 0.22));
    LCTX.strokeText(TEXT, x, y);

    // Purple gradient
    const g = LCTX.createLinearGradient(0, y - textH, 0, y + textH);
    g.addColorStop(0, css('--main'));
    g.addColorStop(1, css('--secondary'));
    LCTX.fillStyle = g;
    LCTX.fillText(TEXT, x, y);

    // Tiny glow seed
    LCTX.save();
    LCTX.shadowColor = css('--glow');
    LCTX.shadowBlur  = 8;
    LCTX.fillRect(x, y - textH, 1, 1);
    LCTX.restore();

    bounds = { x, y, w:textW, h:textH, px };
  }

  const easeOutCubic = t => 1 - Math.pow(1 - t, 3);

  // ---- Erasers ----

  // 5-line spinning star (from canvas center to edges)
  function eraseWithSpinningStar(t){
    const cx = CAN.clientWidth / 2;
    const cy = CAN.clientHeight / 2;

    const angle = (Math.PI * 2) * (STAR_SPINS * t);
    const L = easeOutCubic(t);

    // full canvas diagonal
    const fullLen = Math.sqrt(CAN.clientWidth**2 + CAN.clientHeight**2) * 2;
    const lenNow  = fullLen * L;

    const barH = Math.max(3, Math.round(bounds.px * 0.09)); // slightly thicker to avoid AA crumbs

    LCTX.save();
    LCTX.globalCompositeOperation = 'destination-out';
    LCTX.translate(Math.round(cx), Math.round(cy));
    LCTX.rotate(angle);

    for (let i=0; i<5; i++){
      LCTX.save();
      LCTX.rotate(i * (2*Math.PI/5));
      const x0 = Math.round(-lenNow/2), y0 = Math.round(-barH/2);
      LCTX.fillStyle = '#000';
      LCTX.fillRect(x0, y0, Math.round(lenNow)+2, barH+2);
      LCTX.restore();
    }
    LCTX.restore();
  }

  // Smooth expanding circle (underneath) that ensures a full dissolve
  function eraseWithCircle(t){
    const cx = CAN.clientWidth / 2;
    const cy = CAN.clientHeight / 2;

    // radius to farthest corner
    const maxR = Math.sqrt((CAN.clientWidth/2)**2 + (CAN.clientHeight/2)**2);
    // start a tad later for layering feel, end at 100%
    const tt = Math.min(1, Math.max(0, (t - 0.1) / 0.9)); // delay ~10%
    const r = easeOutCubic(tt) * (maxR + 4); // +4 to overdraw

    LCTX.save();
    LCTX.globalCompositeOperation = 'destination-out';
    LCTX.beginPath();
    LCTX.arc(Math.round(cx), Math.round(cy), r, 0, Math.PI*2);
    LCTX.closePath();
    LCTX.fillStyle = '#000';
    LCTX.fill();
    LCTX.restore();
  }

  // OBS-safe scrub: zero RGB wherever alpha is ~0
  function scrubTransparency(){
    const w = LAYER.width, h = LAYER.height;
    try {
      const img = LCTX.getImageData(0, 0, w, h);
      const d = img.data;
      for (let i = 0; i < d.length; i += 4) {
        if (d[i+3] < 8) { d[i] = 0; d[i+1] = 0; d[i+2] = 0; d[i+3] = 0; }
      }
      LCTX.putImageData(img, 0, 0);
    } catch(e) {
      LCTX.clearRect(0, 0, w, h);
    }
  }

  function drawStage(alpha=1){
    CTX.clearRect(0,0,CAN.clientWidth,CAN.clientHeight);
    if (alpha>0){
      CTX.globalAlpha = alpha;
      CTX.drawImage(LAYER, 0, 0);
      CTX.globalAlpha = 1;
    }
  }

  let t0;
  function frame(now){
    if (!t0) t0 = now;

    const blinkEnd = t0 + BLINKS*BLINK_PERIOD;
    const starEnd  = blinkEnd + STAR_TIME;

    if (now < blinkEnd){
      const phase = ((now - t0) % BLINK_PERIOD) / BLINK_PERIOD;
      drawStage(phase < 0.5 ? 1 : 0);
      requestAnimationFrame(frame);
      return;
    }

    if (now < starEnd){
      const t = (now - blinkEnd) / STAR_TIME;
      // circle first (under), then star
      eraseWithCircle(Math.min(1, t));
      eraseWithSpinningStar(Math.min(1, t));
      drawStage(1);
      requestAnimationFrame(frame);
      return;
    }

    if (!finished){
      scrubTransparency(); // final clean for OBS
      finished = true;
    }
    drawStage(1);
  }

  document.fonts?.load(`16px "Press Start 2P"`).then(() => { resize(); requestAnimationFrame(frame); });
})();
</script>
</body>
</html>
